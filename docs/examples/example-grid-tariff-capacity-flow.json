[
  {
    "id": "2a073d402b1b6573",
    "type": "function",
    "z": "d938c47f.3398f8",
    "name": "Build query for consumption",
    "func": "/*\n   Calculate number of hours to reeive consumption for,\n   that is number of hours in the month until now.\n   Constructs a tibber query to get consumption per hour.\n*/\n\nconst TIBBER_HOME_ID = \"find-your-tibber-home-id-and-replace-this\"\n\nconst timestamp = msg.payload.timestamp\n\n// Stop if hour has not changed\nconst time = new Date(timestamp)\nconst hour = time.getMinutes() // NB Change to getMinutes()\nconst previousHour = context.get(\"previousHour\")\nif(previousHour !== undefined && hour === previousHour) {\n    return\n}\ncontext.set(\"previousHour\", hour)\n\n// Calculate number of hours to query\nconst date = time.getDate() - 1\nconst hour2 = time.getHours()\nconst count = date * 24 + hour2\n\n// Build query\nconst query = `\n{\n  viewer {\n    home (id: \"${TIBBER_HOME_ID}\") {\n      consumption(resolution: HOURLY, last: ${count}) {\n        nodes {\n          from\n          consumption\n        }\n      }\n    }\n  }\n}\n`\n\nmsg.payload = query\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "// Code added here will be run once\n// whenever the node is started.\ncontext.set(\"previousHour\", undefined)",
    "finalize": "",
    "libs": [],
    "x": 330,
    "y": 970,
    "wires": [["cf42844ec5bdfd21"]]
  },
  {
    "id": "cf42844ec5bdfd21",
    "type": "tibber-query",
    "z": "d938c47f.3398f8",
    "name": "Get consumption",
    "active": true,
    "apiEndpointRef": "b70ec5d0.6f8f08",
    "x": 140,
    "y": 1050,
    "wires": [["172bdb20196bc56a"]]
  },
  {
    "id": "b5b84faebe49979e",
    "type": "tibber-feed",
    "z": "d938c47f.3398f8",
    "name": "Get live data",
    "active": true,
    "apiEndpointRef": "b70ec5d0.6f8f08",
    "homeId": "find-your-tibber-home-id-and-replace-this",
    "timestamp": "1",
    "power": "1",
    "lastMeterConsumption": false,
    "accumulatedConsumption": true,
    "accumulatedProduction": false,
    "accumulatedConsumptionLastHour": "1",
    "accumulatedProductionLastHour": false,
    "accumulatedCost": false,
    "accumulatedReward": false,
    "currency": false,
    "minPower": false,
    "averagePower": false,
    "maxPower": false,
    "powerProduction": false,
    "minPowerProduction": false,
    "maxPowerProduction": false,
    "lastMeterProduction": false,
    "powerFactor": false,
    "voltagePhase1": false,
    "voltagePhase2": false,
    "voltagePhase3": false,
    "currentL1": false,
    "currentL2": false,
    "currentL3": false,
    "signalStrength": false,
    "x": 100,
    "y": 950,
    "wires": [["90412687d7504168", "2a073d402b1b6573"]]
  },
  {
    "id": "172bdb20196bc56a",
    "type": "function",
    "z": "d938c47f.3398f8",
    "name": "Find highest per day",
    "func": "const MAX_COUNTING = 3\nconst hours = msg.payload.viewer.home.consumption.nodes\nconst days = new Map()\nhours.forEach (h => {\n    const date = (new Date(h.from)).getDate()\n    if (!days.has(date) || h.consumption > days.get(date).consumption) {\n        days.set(date, {from: h.from, consumption: h.consumption})\n    }\n})\nconst highestToday = days.get((new Date()).getDate())\nconst highestPerDay = [...days.values()].sort((a, b) => b.consumption - a.consumption)\nconst highestCounting = highestPerDay.slice(0, MAX_COUNTING)\nconst currentMonthlyMaxAverage = highestCounting.length === 0 ? 0 : highestCounting.reduce((prev, val) => prev + val.consumption, 0) / highestCounting.length\nmsg.payload = {\n    highestPerDay,\n    highestCounting,\n    highestToday,\n    currentMonthlyMaxAverage\n}\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 370,
    "y": 1030,
    "wires": [["deee9c5a2e504afd"]]
  },
  {
    "id": "90412687d7504168",
    "type": "function",
    "z": "d938c47f.3398f8",
    "name": "Collect estimate for hour",
    "func": "\n// Number of minutes used to calculate assumed consumption:\nconst ESTIMATION_TIME_MINUTES = 1\n\nconst buffer = context.get(\"buffer\") || []\n\n// Add new record to buffer\nconst time = new Date(msg.payload.timestamp)\nconst timeMs = time.getTime()\nconst accumulatedConsumption = msg.payload.accumulatedConsumption\nconst accumulatedConsumptionLastHour = msg.payload.accumulatedConsumptionLastHour\nbuffer.push({timeMs, accumulatedConsumption})\n\nconst currentHour = new Date(msg.payload.timestamp)\ncurrentHour.setMinutes(0)\ncurrentHour.setSeconds(0)\n\n// Remove too old records from buffer\nconst maxAgeMs = ESTIMATION_TIME_MINUTES * 60 * 1000\nlet oldest = buffer[0]\nwhile ((timeMs - oldest.timeMs) > maxAgeMs) {\n    buffer.splice(0, 1)\n    oldest = buffer[0]\n}\ncontext.set(\"buffer\", buffer)\n\n// Calculate buffer\nconst periodMs = buffer[buffer.length - 1].timeMs - buffer[0].timeMs\nconst consumptionInPeriod = buffer[buffer.length - 1].accumulatedConsumption - buffer[0].accumulatedConsumption\nif (periodMs === 0) {\n    return // First item in buffer\n}\n\n// Estimate remaining of current hour\nconst timeLeftMs = (60 * 60 * 1000) - (time.getMinutes() * 60000 + time.getSeconds() * 1000 + time.getMilliseconds())\nconst consumptionLeft = consumptionInPeriod / periodMs * timeLeftMs\nconst averageConsumptionNow = consumptionInPeriod / periodMs * 60 * 60 * 1000\n\n// Estimate total hour\nconst hourEstimate = accumulatedConsumptionLastHour + consumptionLeft + 0 // Change for testing\n\nmsg.payload = {\n  accumulatedConsumption,\n  accumulatedConsumptionLastHour,\n  periodMs,\n  consumptionInPeriod,\n  averageConsumptionNow,\n  timeLeftMs,\n  consumptionLeft,\n  hourEstimate,\n  currentHour\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "// Code added here will be run once\n// whenever the node is started.\ncontext.set(\"buffer\", [])",
    "finalize": "",
    "libs": [],
    "x": 320,
    "y": 930,
    "wires": [["deee9c5a2e504afd"]]
  },
  {
    "id": "deee9c5a2e504afd",
    "type": "function",
    "z": "d938c47f.3398f8",
    "name": "Calculate values",
    "func": "const STEPS = [2, 5, 10, 15, 20]\nconst MAX_COUNTING = 3 // Number of days to calculate month\nconst BUFFER = 0.5 // Closer to limit increases level\nconst SAFE_ZONE = 2 // Further from limit reduces level\nconst ALARM = 8 // Min level that causes status to be alarm\n\nconst ha = global.get(\"homeassistant\").homeAssistant\nif(!ha.isConnected) {\n    return\n}\n\nfunction calculateLevel(hourEstimate, \n                        currentHourRanking,\n                        highestCountingAverageWithCurrent,\n                        nextStep) {\n    if(currentHourRanking === 0) {\n        return 0\n    }\n    if(highestCountingAverageWithCurrent > nextStep) {\n        return 9\n    }\n    if(highestCountingAverageWithCurrent > (nextStep - BUFFER)) {\n        return 8\n    }\n    if(hourEstimate > nextStep) {\n        return 7\n    }\n    if(hourEstimate > (nextStep - BUFFER)) {\n        return 6\n    }\n    if(currentHourRanking === 1 && (nextStep - hourEstimate) < SAFE_ZONE) {\n        return 5\n    }\n    if(currentHourRanking === 2 && (nextStep - hourEstimate) < SAFE_ZONE) {\n        return 4\n    }\n    if(currentHourRanking === 3 && (nextStep - hourEstimate) < SAFE_ZONE) {\n        return 3\n    }\n    if(currentHourRanking === 1) {\n        return 2\n    }\n    if(currentHourRanking === 2) {\n        return 1\n    }\n    return 0\n}\n\n\nif (msg.payload.highestPerDay) {\n    context.set(\"highestPerDay\", msg.payload.highestPerDay)\n    context.set(\"highestCounting\", msg.payload.highestCounting)\n    context.set(\"highestToday\", msg.payload.highestToday)\n    context.set(\"currentMonthlyMaxAverage\", msg.payload.currentMonthlyMaxAverage)\n    node.status({fill:\"green\",shape:\"ring\",text:\"Got ranking\"});\n    return\n}\n\nconst highestPerDay = context.get(\"highestPerDay\")\nconst highestCounting = context.get(\"highestCounting\")\nconst highestToday = context.get(\"highestToday\")\nconst currentMonthlyMaxAverage = context.get(\"currentMonthlyMaxAverage\")\nconst hourEstimate = msg.payload.hourEstimate\nconst timeLeftMs = msg.payload.timeLeftMs\nconst timeLeftSec = timeLeftMs / 1000\nconst periodMs = msg.payload.periodMs\nconst accumulatedConsumption = msg.payload.accumulatedConsumption\nconst accumulatedConsumptionLastHour = msg.payload.accumulatedConsumptionLastHour\nconst consumptionLeft = msg.payload.consumptionLeft\nconst averageConsumptionNow = msg.payload.averageConsumptionNow\nconst currentHour = msg.payload.currentHour\n\nif (timeLeftSec === 0) {\n    return null\n}\n\nif (!highestPerDay) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"No highest per day\"});\n    return\n}\nif (!highestToday) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"No highest today\"});\n    return\n}\nif (!hourEstimate) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"No estimate\"});\n    return\n}\n\nconst currentStep = STEPS.reduceRight((prev, val) => val > currentMonthlyMaxAverage ? val : prev, STEPS[STEPS.length - 1])\n\n// Set currentHourRanking\nlet currentHourRanking = MAX_COUNTING + 1\nfor(let i = highestCounting.length - 1; i >= 0; i--) {\n    if(hourEstimate > highestCounting[i].consumption) {\n        currentHourRanking = i + 1\n    }\n}\nif(hourEstimate < highestToday.consumption) {\n    currentHourRanking = 0\n}\n\nconst current = {from: currentHour, consumption: hourEstimate}\nconst highestCountingWithCurrent = [...highestCounting, current].sort((a, b) => b.consumption - a.consumption).slice(0, highestCounting.length)\nconst currentMonthlyEstimate = highestCountingWithCurrent.length === 0 ? 0 : highestCountingWithCurrent.reduce((prev, val) => prev + val.consumption, 0) / highestCountingWithCurrent.length\n\n// Set alarm level\nconst alarmLevel = calculateLevel(\n    hourEstimate,\n    currentHourRanking,\n    currentMonthlyEstimate,\n    currentStep)\n\n// Evaluate status\nconst status = alarmLevel >= ALARM ? \"Alarm\" : alarmLevel > 0 ? \"Warning\" : \"Ok\"\n\n// Calculate reduction\nconst reductionRequired = alarmLevel < ALARM ? 0 :\n    Math.max((currentMonthlyEstimate - currentStep) * highestCounting.length, 0)\n    * 3600 / timeLeftSec;\nconst reductionRecommended = alarmLevel < 3 ? 0 :\n    Math.max(hourEstimate + SAFE_ZONE - currentStep, 0)\n    * 3600 / timeLeftSec;\n\n// Calculate increase possible\nconst increasePossible = alarmLevel >= 3 ? 0 :\n    Math.max(currentStep - hourEstimate - SAFE_ZONE, 0)\n    * 3600 / timeLeftSec;\n\n// Create output\nconst fill = status === \"Ok\" ? \"green\" : status === \"Alarm\" ? \"red\" : \"yellow\";\nnode.status({fill,shape:\"dot\",text:\"Working\"});\n\nconst RESOLUTION = 1000\n\nconst payload = {\n    status, // Ok, Warning, Alarm\n    statusOk: status === \"Ok\",\n    statusWarning: status === \"Warning\",\n    statusAlarm: status === \"Alarm\",\n    alarmLevel,\n    highestPerDay,\n    highestCounting,\n    highestCountingWithCurrent,\n    highestToday,\n    currentMonthlyEstimate: Math.round(currentMonthlyEstimate * RESOLUTION) / RESOLUTION,\n    accumulatedConsumptionLastHour: Math.round(accumulatedConsumptionLastHour * RESOLUTION) / RESOLUTION,\n    consumptionLeft: Math.round(consumptionLeft * RESOLUTION) / RESOLUTION,\n    hourEstimate: Math.round(hourEstimate * RESOLUTION) / RESOLUTION,\n    averageConsumptionNow: Math.round(averageConsumptionNow * RESOLUTION) / RESOLUTION,\n    reductionRequired: Math.round(reductionRequired * RESOLUTION) / RESOLUTION,\n    reductionRecommended: Math.round(reductionRecommended * RESOLUTION) / RESOLUTION,\n    increasePossible: Math.round(increasePossible * RESOLUTION) / RESOLUTION,\n    currentStep,\n    currentHourRanking,\n    timeLeftSec,\n    periodMs,\n    accumulatedConsumption\n}\n\nmsg.payload = payload\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 580,
    "y": 930,
    "wires": [
      [
        "3f26ca0dae54f120",
        "a9d94489cb429ac1",
        "b7a03b817ed5481e",
        "dbc3786eebd34825",
        "cd77d1f6acdcebde",
        "0fb7cffd909675d4",
        "949b11e8d1d05398",
        "e0a57b0ae1ef8424",
        "bcece06057fe66ef",
        "72886b57ce2fcd4e",
        "e4e1dfad359aa8b8",
        "291a07c14f9d2dbf",
        "05e693dab4f13d93",
        "15b8bd222daca026",
        "241d0b3a591a26b2",
        "7b9668ca57ce9fef",
        "ea38e7cbf080f15f",
        "51c0696c32cc1822",
        "ac0b86c136f40790",
        "3cdb68064ac5a5bc"
      ]
    ]
  },
  {
    "id": "3f26ca0dae54f120",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Status",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Status"
      },
      {
        "property": "device_class",
        "value": ""
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": ""
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.status",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 780,
    "y": 990,
    "wires": [[]]
  },
  {
    "id": "a9d94489cb429ac1",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Warning",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "binary_sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Warning"
      },
      {
        "property": "device_class",
        "value": "none"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": ""
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.statusWarning",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 790,
    "y": 1090,
    "wires": [[]]
  },
  {
    "id": "b7a03b817ed5481e",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Alarm",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "binary_sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Alarm"
      },
      {
        "property": "device_class",
        "value": "none"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": ""
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.statusAlarm",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 780,
    "y": 1140,
    "wires": [[]]
  },
  {
    "id": "dbc3786eebd34825",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Ok",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "binary_sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Ok"
      },
      {
        "property": "device_class",
        "value": "none"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": ""
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.statusOk",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 770,
    "y": 1040,
    "wires": [[]]
  },
  {
    "id": "cd77d1f6acdcebde",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Current Step",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Current Step"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.currentStep",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 800,
    "y": 1240,
    "wires": [[]]
  },
  {
    "id": "0fb7cffd909675d4",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Hour Estimate",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Hour Estimate"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.hourEstimate",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 810,
    "y": 1290,
    "wires": [[]]
  },
  {
    "id": "949b11e8d1d05398",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Current Hour Ranking",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Current Hour Ranking"
      },
      {
        "property": "device_class",
        "value": ""
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": ""
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.currentHourRanking",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 830,
    "y": 1340,
    "wires": [[]]
  },
  {
    "id": "e0a57b0ae1ef8424",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Monthly Estimate",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Monthly Estimate"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.currentMonthlyEstimate",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 820,
    "y": 1390,
    "wires": [[]]
  },
  {
    "id": "bcece06057fe66ef",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Highest Today",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Highest Today"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.highestToday.consumption",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 1090,
    "y": 970,
    "wires": [[]]
  },
  {
    "id": "72886b57ce2fcd4e",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Highest Today Hour",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Highest Today Hour"
      },
      {
        "property": "device_class",
        "value": "timestamp"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": ""
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.highestToday.from",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 1100,
    "y": 1020,
    "wires": [[]]
  },
  {
    "id": "e4e1dfad359aa8b8",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Reduction Required",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Reduction Required"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.reductionRequired",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 1110,
    "y": 1070,
    "wires": [[]]
  },
  {
    "id": "291a07c14f9d2dbf",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Estimate Rest Of Hour",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Estimate Rest Of Hour"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.consumptionLeft",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 1110,
    "y": 1230,
    "wires": [[]]
  },
  {
    "id": "05e693dab4f13d93",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Consumption Accumulated Hour",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Consumption Accumulated Hour"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.accumulatedConsumptionLastHour",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 1130,
    "y": 1280,
    "wires": [[]]
  },
  {
    "id": "15b8bd222daca026",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Time Left",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Time Left"
      },
      {
        "property": "device_class",
        "value": "time"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "sec"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.timeLeftSec",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 1070,
    "y": 1330,
    "wires": [[]]
  },
  {
    "id": "241d0b3a591a26b2",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Consumption Now",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Consumption Now"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.averageConsumptionNow",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 1100,
    "y": 1390,
    "wires": [[]]
  },
  {
    "id": "3cdb68064ac5a5bc",
    "type": "function",
    "z": "d938c47f.3398f8",
    "name": "Reduction Actions",
    "func": "const MIN_CONSUMPTION_TO_CARE = 0.05 // Do not reduce unless at least 50W\n\nconst actions = flow.get(\"actions\")\nconst ha = global.get(\"homeassistant\").homeAssistant\n\nlet reductionRequired = msg.payload.reductionRequired\nlet reductionRecommended = msg.payload.reductionRecommended\n\nif(reductionRecommended <= 0) {\n  return null\n}\n\nfunction takeAction(action, consumption ) {\n  const info = {\n    time: new Date().toISOString(),\n    name: \"Reduction action\",\n    data: msg.payload,\n    action\n  }\n  node.send([{ payload: action.payloadToTakeAction }, {payload: info}])\n  reductionRequired = Math.max(0, reductionRequired - consumption)\n  reductionRecommended = Math.max(0, reductionRecommended - consumption)\n  action.actionTaken = true\n  action.actionTime = Date.now()\n  action.savedConsumption = consumption\n  flow.set(\"actions\", actions)\n}\n\nactions\n.filter(a => msg.payload.alarmLevel >= a.minAlarmLevel && !a.actionTaken)\n.forEach(a => {\n    const sensor = ha.states[a.sensor]\n    const consumption = sensor.state\n  if (consumption < MIN_CONSUMPTION_TO_CARE) {\n      return\n    }\n  if (reductionRequired > 0 || (reductionRecommended > 0 && a.reduceWhenRecommended)) {\n    takeAction(a, consumption)\n  }\n})\n    \n",
    "outputs": 2,
    "noerr": 0,
    "initialize": "// Code added here will be run once\n// whenever the node is started.\n\nconst actions = [\n    { \n        sensor: \"sensor.varmtvannsbereder_electric_consumption_w\",\n        name: \"Varmtvannsbereder\",\n        id: \"vvb\",\n        minAlarmLevel: 3,\n        reduceWhenRecommended: true,\n        minTimeOffSec: 300,\n        payloadToTakeAction: {\n            domain: \"switch\",\n            service: \"turn_off\",\n            target: {\n                entity_id: [\"switch.varmtvannsbereder\"]\n            }\n        },\n        payloadToResetAction: {\n            domain: \"switch\",\n            service: \"turn_on\",\n            target: {\n                entity_id: [\"switch.varmtvannsbereder\"]\n            }\n        }\n    },\n    { \n        sensor: \"sensor.varme_gulv_bad_electric_consumption_w_2\",\n        name: \"Varme gulv bad 1. etg.\",\n        id: \"gulvbad\",\n        minAlarmLevel: 3,\n        reduceWhenRecommended: true,\n        minTimeOffSec: 300,\n        payloadToTakeAction: {\n            domain: \"climate\",\n            service: \"turn_off\",\n            target: {\n                entity_id: [\"climate.varme_gulv_bad_2\"]\n            }\n        },\n        payloadToResetAction: {\n            domain: \"climate\",\n            service: \"turn_on\",\n            target: {\n                entity_id: [\"climate.varme_gulv_bad_2\"]\n            }\n        }\n    },\n    { \n        sensor: \"sensor.varme_gulv_gang_electric_consumption_w\",\n        name: \"Varme gulv gang 1. etg.\",\n        id: \"gulvgang\",\n        minAlarmLevel: 3,\n        reduceWhenRecommended: true,\n        minTimeOffSec: 300,\n        payloadToTakeAction: {\n            domain: \"climate\",\n            service: \"turn_off\",\n            target: {\n                entity_id: [\"climate.varme_gulv_gang\"]\n            }\n        },\n        payloadToResetAction: {\n            domain: \"climate\",\n            service: \"turn_on\",\n            target: {\n                entity_id: [\"climate.varme_gulv_gang\"]\n            }\n        }\n    },\n    {\n        sensor: \"sensor.varme_gulv_kjellerstue_electric_consumption_w\",\n        name: \"Varme gulv kjellerstue\",\n        id: \"gulvkjeller\",\n        minAlarmLevel: 3,\n        reduceWhenRecommended: true,\n        minTimeOffSec: 300,\n        payloadToTakeAction: {\n            domain: \"climate\",\n            service: \"turn_off\",\n            target: {\n                entity_id: [\"climate.varme_gulv_kjellerstue\"]\n            }\n        },\n        payloadToResetAction: {\n            domain: \"climate\",\n            service: \"turn_on\",\n            target: {\n                entity_id: [\"climate.varme_gulv_kjellerstue\"]\n            }\n        }\n    }\n]\n\n// Set default values for all actions\nactions.forEach(a => {\n    a.actionTaken = false\n    a.savedConsumption = 0\n})\n\nflow.set(\"actions\", actions)\n",
    "finalize": "const actions = flow.get(\"actions\")\n\nactions\n    .filter(a => a.actionTaken)\n    .forEach(a => \n        node.send({ payload: a.payloadToResetAction })\n    )",
    "libs": [],
    "x": 250,
    "y": 1210,
    "wires": [["28a20e58f1058b6d"], ["1d738e15969dd163"]]
  },
  {
    "id": "7b9668ca57ce9fef",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Alarm Level",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Alarm Level"
      },
      {
        "property": "device_class",
        "value": ""
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": ""
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.alarmLevel",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 800,
    "y": 1190,
    "wires": [[]]
  },
  {
    "id": "ea38e7cbf080f15f",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Reduction Recommended",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Reduction Recommended"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.reductionRecommended",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 1100,
    "y": 1120,
    "wires": [[]]
  },
  {
    "id": "51c0696c32cc1822",
    "type": "ha-entity",
    "z": "d938c47f.3398f8",
    "name": "Capacity Increase Possible",
    "server": "ec4a12a1.b2be9",
    "version": 2,
    "debugenabled": false,
    "outputs": 1,
    "entityType": "sensor",
    "config": [
      {
        "property": "name",
        "value": "PS Cap Increase Possible"
      },
      {
        "property": "device_class",
        "value": "power"
      },
      {
        "property": "icon",
        "value": ""
      },
      {
        "property": "unit_of_measurement",
        "value": "kW"
      },
      {
        "property": "state_class",
        "value": ""
      },
      {
        "property": "last_reset",
        "value": ""
      }
    ],
    "state": "payload.increasePossible",
    "stateType": "msg",
    "attributes": [],
    "resend": true,
    "outputLocation": "payload",
    "outputLocationType": "none",
    "inputOverride": "allow",
    "outputOnStateChange": false,
    "outputPayload": "",
    "outputPayloadType": "str",
    "x": 1100,
    "y": 1170,
    "wires": [[]]
  },
  {
    "id": "ac0b86c136f40790",
    "type": "function",
    "z": "d938c47f.3398f8",
    "name": "Reset Actions",
    "func": "\nconst actions = flow.get(\"actions\")\nconst ha = global.get(\"homeassistant\").homeAssistant\n\nconst BUFFER_TO_RESET = 1 // Must have 1kW extra to perform reset\n\nlet increasePossible = msg.payload.increasePossible\n\nif (increasePossible <= 0) {\n  return null\n}\n\nfunction resetAction(action) {\n  const info = {\n    time: new Date().toISOString(),\n    name: \"Reset action\",\n    data: msg.paylaod,\n    action\n  }\n  node.send([{ payload: action.payloadToResetAction}, {payload: info}])\n  increasePossible -= action.savedConsumption\n  action.actionTaken = false\n  action.savedConsumption = 0\n  flow.set(\"actions\", actions)\n}\n\nactions\n  .filter(a => a.actionTaken\n    && (a.savedConsumption + BUFFER_TO_RESET) <= increasePossible\n    && (Date.now() - a.actionTime > a.minTimeOffSec * 1000)\n  ).forEach(a => resetAction(a))\n",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 240,
    "y": 1270,
    "wires": [["28a20e58f1058b6d"], ["1d738e15969dd163"]]
  },
  {
    "id": "28a20e58f1058b6d",
    "type": "api-call-service",
    "z": "d938c47f.3398f8",
    "name": "Perform action",
    "server": "ec4a12a1.b2be9",
    "version": 5,
    "debugenabled": false,
    "domain": "",
    "service": "",
    "areaId": [],
    "deviceId": [],
    "entityId": [],
    "data": "",
    "dataType": "jsonata",
    "mergeContext": "",
    "mustacheAltTags": false,
    "outputProperties": [
      {
        "property": "payload",
        "propertyType": "msg",
        "value": "payload",
        "valueType": "msg"
      }
    ],
    "queue": "none",
    "x": 540,
    "y": 1240,
    "wires": [[]]
  },
  {
    "id": "1d738e15969dd163",
    "type": "file",
    "z": "d938c47f.3398f8",
    "name": "Save actions to file",
    "filename": "/share/capacity-actions.txt",
    "filenameType": "str",
    "appendNewline": true,
    "createDir": false,
    "overwriteFile": "false",
    "encoding": "none",
    "x": 540,
    "y": 1320,
    "wires": [[]]
  },
  {
    "id": "0656818b7253b0aa",
    "type": "catch",
    "z": "d938c47f.3398f8",
    "name": "Catch action errors",
    "scope": ["3cdb68064ac5a5bc", "ac0b86c136f40790"],
    "uncaught": false,
    "x": 250,
    "y": 1340,
    "wires": [["1d738e15969dd163"]]
  },
  {
    "id": "b70ec5d0.6f8f08",
    "type": "tibber-api-endpoint",
    "feedUrl": "wss://api.tibber.com/v1-beta/gql/subscriptions",
    "queryUrl": "https://api.tibber.com/v1-beta/gql",
    "name": "Tibber API"
  }
]
